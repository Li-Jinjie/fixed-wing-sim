## 记录mavsim值得我学习的地方

### Chapter 1 - 3

1. 所有可以重复使用的变量提前存在parameters中，比如各种gamma，在程序中只是简单的加和乘，减少重复计算过程。
2. 变量名取的和书上一样，取的真是太好了，完全可以像书上一样敲公式。
3. class内部的函数区分权限。_开头的函数和变量是半私有变量，在类外无法调用，在类内可以调用。这比我之前毕设时候的类写的好太多了。以后在写类的时候一定要区分好不同函数和参数的作用域。
   - “_”：以单下划线开头的表示的是**protected类型的变量**，即**只能允许其本身与子类进行访问**；同时表示弱内部变量标示，如，当使用"from moduleNmae import *"时，不会将以一个下划线开头的对象引入。
   - “__”：双下划线的表示的**是私有类型的变量**。只能是允许这个类本身进行访问了，连子类也不可以，**这类属性在运行时属性名会加上单下划线和类名**。
4. 全用numpy可以提速，因为numpy底层是C实现的。在numpy中，用@表示矩阵乘法， 用[[],[]]的形式表示矩阵和列向量，将矩阵和列向量的形式统一起来。
5. 在第三章中，用四阶龙格库塔法求微分方程，真是活学活用！
6. 画的界面特别直观，还能拖动，用pyqt画的。

### Chapter 4
1. 风的模型，需要用计算传递函数。根据transfer_function.py里的程序，具体的实现过程如下：

   1. 给定传递函数计算状态，用可控标准型最小实现得到ABC方程
   2. 结合线性离散系统的计算公式，得到离散状态下的ABC方程
   3. 用矩阵相乘的方式，得到每迭代一步的state

   - remark：在书中假设Va是“a constant nominal airspeed”， 我觉得这可能是与传递函数的实现方式有关。如果Va是一个时变系数，那么wind系统就是时变线性系统，可能就无法用transfer_function.py中的方法进行离散化处理。

2. wind里边涉及到的坐标变换我用的是旋转矩阵。之后需要借助rospy或者自己写工具，使用quaternion进行坐标变换。

3. 一开始我以为没有失速在里边，后来发现是电机太强了。如果这个电机太强，由于迎角是机体x轴与空速Va在机体xy平面的投影的夹角，如果这个电机拉力很大，则即使从地面上看已经朝天飞了，但实际并没有失速。如果要体现失速效果，可以用较小的推力和较大的升降舵。

4. 在飞机中，u，v，w是地速Vg在机体坐标系的投影，具体在page18。这里虽然机体坐标系是一直移动的，但还是静系，因为V_g^b的定义是**相对于惯性坐标系的速度**在body坐标系下的投影。

5. gamma chi的数值可以根据书p22的公式推导出来。但是需要注意，arcsin的有效值是-pi/2 to pi/2，arctan的有效值是-pi to pi

6. 想改成用键盘输入，但pyqt的输入好像有点不同，得专门写一下。

### Chapter 5

1. 求解trim问题，其实是求解一个最优化问题，使用了scipy.optimize.minimize()函数。现在的问题在于求不到那个相等的解，而且解对初值**特别**敏感。python中是直接求解状态（17个变量），和书上的算法（3个变量）还是很不一样的。~~我觉得这造成了**高维的搜索空间**，导致优化算法**更难收敛**~~。2021.1.21更新：我写的有问题，参考一下youtube上教学视频的结构。
   1. 这个改了。要注意，由于我是把forces_and_moments单独拆分开的，因此用到了Va，alpha，beta这些中间变量。在trim.py中计算时，更新设定新状态后，要先使用_update_velocity_data()去得到匹配的中间变量Va等，才能继续使用 _forces_moments(delta)去得到正确的forces和moments。
2. trim函数里没有封装转弯半径R。之后如果有需要可以封装一下。用R = np.inf表示直线。
3. 对于非线性方程，有等式约束，可以采用SLSQP方法，详见https://docs.scipy.org/doc/scipy/reference/tutorial/optimize.html#sequential-least-squares-programming-slsqp-algorithm-method-slsqp。
4. 这一章编的程序（线性化模型）对之后章节的作业没有影响。
5. 这一章需要的C_X_0, C_X_alpha等参数书中没有给出计算公式，如果要实现需要查一下书中参考的资料。

