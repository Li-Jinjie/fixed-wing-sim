## 记录mavsim值得我学习的地方

### Chapter 1 - 3

1. 所有可以重复使用的变量提前存在parameters中，比如各种gamma，在程序中只是简单的加和乘，减少重复计算过程。
2. 变量名取的和书上一样，取的真是太好了，完全可以像书上一样敲公式。
3. class内部的函数区分权限。_开头的函数和变量是半私有变量，在类外无法调用，在类内可以调用。这比我之前毕设时候的类写的好太多了。以后在写类的时候一定要区分好不同函数和参数的作用域。
   - “_”：以单下划线开头的表示的是**protected类型的变量**，即**只能允许其本身与子类进行访问**；同时表示弱内部变量标示，如，当使用"from moduleNmae import *"时，不会将以一个下划线开头的对象引入。
   - “__”：双下划线的表示的**是私有类型的变量**。只能是允许这个类本身进行访问了，连子类也不可以，**这类属性在运行时属性名会加上单下划线和类名**。
4. 全用numpy可以提速，因为numpy底层是C实现的。在numpy中，用@表示矩阵乘法， 用[[],[]]的形式表示矩阵和列向量，将矩阵和列向量的形式统一起来。
5. 在第三章中，用四阶龙格库塔法求微分方程，真是活学活用！
6. 画的界面特别直观，还能拖动，用pyqt画的。







### Chapter 4
1. 风的模型，需要用计算传递函数。根据transfer_function.py里的程序，具体的实现过程如下：

   1. 给定传递函数计算状态，用可控标准型最小实现得到ABC方程
   2. 结合线性离散系统的计算公式，得到离散状态下的ABC方程
   3. 用矩阵相乘的方式，得到每迭代一步的state

   - remark：在书中假设Va是“a constant nominal airspeed”， 我觉得这可能是与传递函数的实现方式有关。如果Va是一个时变系数，那么wind系统就是时变线性系统，可能就无法用transfer_function.py中的方法进行离散化处理。

2. wind里边涉及到的坐标变换我用的是旋转矩阵。之后需要借助rospy或者自己写工具，使用quaternion进行坐标变换。

3. 一开始我以为没有失速在里边，后来发现是电机太强了。如果这个电机太强，由于迎角是机体x轴与空速Va在机体xy平面的投影的夹角，如果这个电机拉力很大，则即使从地面上看已经朝天飞了，但实际并没有失速。如果要体现失速效果，可以用较小的推力和较大的升降舵。

4. 在飞机中，u，v，w是地速Vg在机体坐标系的投影，具体在page18。这里虽然机体坐标系是一直移动的，但还是静系，因为V_g^b的定义是**相对于惯性坐标系的速度**在body坐标系下的投影。

5. gamma chi的数值可以根据书p22的公式推导出来。但是需要注意，arcsin的有效值是-pi/2 to pi/2，arctan的有效值是-pi to pi

